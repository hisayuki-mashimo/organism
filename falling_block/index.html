<html>
  <head>
    <meta charset="utf-8" />
    <style>
      body {
        margin: 0;
        padding: 0;
        overscroll-behavior-x: none;
        overscroll-behavior-y: none;
      }
      #contents {
        display: grid;
        grid-template-columns: auto auto;
        grid-template-rows: auto auto;
        margin: 10px 0 0 10px;
      }
      .wrapper {
        position: relative;
        box-sizing: border-box;
        border: solid 1px #aaaaaa;
        margin: 0 10px 10px 0;
        display: flex;
        align-items: center;
        overflow: hidden;
      }
      .wrapper canvas {
        position: absolute;
        top: 0;
        left: 0;
      }
      #form {
        grid-column: 1;
        grid-row: 1;
        padding: 5px;
        justify-content: space-between;
      }
      #focal-length-meter {
        position: relative;
        height: 24px;
        width: 80%;
      }
      #focal-length-meter::before {
        content: "";
        position: absolute;
        display: block;
        width: 100%;
        height: 1px;
        top: 50%;
        border-top: solid 1px #aaaaaa;
      }
      #focal-length-meter-handle {
        position: absolute;
        top: 0;
        width: 10px;
        height: calc(100% - 2px);
        background-color: #ffffff;
        border: solid 1px #888888;
      }
      #display-wrapper {
        grid-column: 1;
        grid-row: 2;
      }
      @media screen and (max-width: 1000px) {
        #contents {
          grid-template-columns: auto;
          grid-template-rows: auto auto auto auto;
        }
      }
    </style>
  </head>
  <body>
    <div id="contents">
      <div class="wrapper" id="form">
        <div id="title">中心点距離</div>
        <div id="focal-length-meter">
          <div id="focal-length-meter-handle"></div>
        </div>
      </div>
      <div class="wrapper canvas-wrapper" id="display-wrapper">
        <canvas class="canvas" id="display"></canvas>
      </div>
    </div>
    <script src="../earth_maker/debug.js"></script>
    <script>
      const R = 150;
      const capacity = 10;
      const displaySize = 500;
      const displayRadius = displaySize / 2;
      const vectorSlideRadius = displaySize / 8 * 3;

      const blockFormations = [
        {P: [[0, 0], [0, -1], [0, 1], [0, 2]], C: [255, 0, 0]},
        {P: [[0, 0], [0, -1], [-1, -1], [0, 1]], C: [0, 128, 255]},
        {P: [[0, 0], [0, -1], [-1, 1], [0, 1]], C: [255, 255, 0]},
        {P: [[0, 0], [-1, 0], [0, 1], [1, 1]], C: [0, 170, 0]},
        {P: [[0, 0], [1, 0], [0, 1], [1, -1]], C: [128, 0, 170]},
        {P: [[0, 0], [-1, 0], [1, 0], [0, 1]], C: [255, 80, 170]},
        {P: [[0, 0], [1, 0], [0, 1], [1, 1]], C: [0, 0, 255]},
      ];

      const display = document.getElementById('display');
      const displayWrapper = document.getElementById('display-wrapper');
      const displayContext = display.getContext('2d');
      const meter = document.getElementById('focal-length-meter');
      const meterHandle = document.getElementById('focal-length-meter-handle');
      display.style.width = `${displaySize}px`;
      display.setAttribute('width', displaySize);
      display.setAttribute('height', displaySize);
      displayWrapper.style.height = `${displaySize}px`;

      const keyMap = {
        ArrowUp: 'U',
        ArrowRight: 'R',
        ArrowDown: 'D',
        ArrowLeft: 'L',
        KeyZ: [1, 0, 0],
        KeyA: [3, 0, 0],
        KeyX: [0, 1, 0],
        KeyS: [0, 3, 0],
        KeyC: [0, 0, 1],
        KeyD: [0, 0, 3],
      };
      const directionMap = { U: 0, R: 1, D: 2, L: 3 };

      // 内部変数
      let focalLengthPercentage = 2;
      let moveSwitch = false;
      let rotationSwitch = false;
      let latestMoveX = 0;
      let latestMoveY = 0;
      let latestBaseX = 0;
      let latestBaseY = 0;
      let latestPointerX = 0;
      let latestPointerY = 0;
      let moveType = 'vector';
      let animationSwitch = false;
      // let blocks = [{ P: { X:  0, Y:  0, Z:  0 }, C: [200, 255, 248] }];
      let blocks = [
        { P: { X:  0, Y:  0, Z:  0 }, C: [200, 255, 248] },
        { P: { X:  1, Y:  1, Z:  1 }, C: [255, 200, 0] },
        { P: { X:  1, Y:  0, Z:  1 }, C: [255, 200, 0] },
        { P: { X:  1, Y:  0, Z:  0 }, C: [255, 200, 0] },
        { P: { X:  1, Y:  1, Z:  0 }, C: [255, 200, 0] },
        { P: { X:  0, Y:  1, Z:  1 }, C: [200, 100, 200] },
        { P: { X:  0, Y:  0, Z:  1 }, C: [200, 100, 200] },
        { P: { X: -1, Y:  0, Z:  1 }, C: [200, 100, 200] },
        { P: { X: -1, Y:  1, Z:  1 }, C: [200, 100, 200] },
        { P: { X:  1, Y: -1, Z:  1 }, C: [100, 200, 200] },
        { P: { X:  1, Y: -1, Z:  0 }, C: [100, 200, 200] },
        { P: { X:  0, Y: -1, Z:  0 }, C: [100, 200, 200] },
        { P: { X:  0, Y: -1, Z:  1 }, C: [100, 200, 200] },
        { P: { X: -1, Y: -1, Z:  1 }, C: [255,  80, 120] },
        { P: { X: -1, Y: -1, Z:  0 }, C: [255,  80, 120] },
        { P: { X: -1, Y:  0, Z:  0 }, C: [255,  80, 120] },
        { P: { X: -1, Y: -1, Z: -1 }, C: [255,  80, 120] },
        { P: { X:  0, Y:  0, Z: -1 }, C: [ 80,  80, 255] },
        { P: { X:  0, Y: -1, Z: -1 }, C: [ 80,  80, 255] },
        { P: { X: -1, Y:  0, Z: -1 }, C: [ 80,  80, 255] },
        { P: { X: -1, Y:  1, Z: -1 }, C: [ 80,  80, 255] },

        { P: { X:  0, Y:  1, Z:  0 }, C: [160, 160, 160] },
        { P: { X:  0, Y:  1, Z: -1 }, C: [160, 160, 160] },
        { P: { X: -1, Y:  1, Z:  0 }, C: [160, 160, 160] },
        { P: { X:  1, Y:  1, Z: -1 }, C: [160, 160, 160] },
      ];
      let block = null;
      let focalLengthSwitch = false;
      let meterHandleDiffX = 0;
      // 位置軸: 静止状態の対象物の基本姿勢からの傾きを表す軸
      let positionAxisX = Math.PI / 180 * 40; // 位置軸のZ軸(正面方向軸)に対する角度(0 ~ π)
      let positionAxisY = Math.PI / 180 * -50; // 位置軸のY軸(上下方向軸)に対する角度(-π ~ π)
      let positionAxisL = Math.PI / 180 * 50; // 位置軸に対する回転角度(-π ~ π)
      // 回転軸: 自転するベースとなる軸
      let momentAxisX = 0; // 位置軸のZ軸(正面方向軸)に対する角度(0 ~ π)
      let momentAxisY = 0; // 位置軸のY軸(上下方向軸)に対する角度(-π ~ π)
      let momentAxisL = 0; // 位置軸に対する回転角度(-π ~ π)
      let diffAxisL = 0;
      let axisX = positionAxisX;
      let axisY = positionAxisY;
      let axisL = positionAxisL;
      let lightX = Math.PI / 180 * 70; // 光源軸のZ軸(正面方向軸)に対する角度(0 ~ π)
      let lightY = Math.PI / 180 * 60; // 光源軸のY軸(上下方向軸)に対する角度(-π ~ π)
      let time = 0;
      let score = 0;

      const calculateBlockPosition = (pos, considerFocalLength) => {
        let [X, Y, Z] = [0, 0, 0];

        const RZ0 = Math.pow(pos.X * pos.X + pos.Y * pos.Y, 1 / 2); // Z面上の半径
        const TZ0 = RZ0 > 0 ? (Math.acos(pos.Y / RZ0) * (pos.X > 0 ? 1 : -1)) : 0;
        const TZ1 = TZ0 + axisL; // 回転角度の加算
        const LX1 = Math.sin(TZ1) * RZ0; // 回転軸に対するX軸上の相対距離
        const LY1 = Math.cos(TZ1) * RZ0; // 回転軸に対するY軸上の相対距離
        const RX1 = Math.pow(LY1 * LY1 + pos.Z * pos.Z, 1 / 2);
        const TX1 = RX1 > 0 ? (Math.acos(pos.Z / RX1) * (LY1 >= 0 ? 1 : -1)) : 0;
        const TX2 = TX1 + axisX;
        const LY2 = Math.sin(TX2) * RX1;
        const LZ2 = Math.cos(TX2) * RX1;
        const RZ2 = Math.pow(LX1 * LX1 + LY2 * LY2, 1 / 2);
        const TZ2 = RZ2 > 0 ? (Math.acos(LY2 / RZ2) * (LX1 > 0 ? 1 : -1)) : 0;
        const TZ3 = TZ2 + axisY;
        const LX3 = Math.sin(TZ3) * RZ2;
        const LY3 = Math.cos(TZ3) * RZ2;

        X = LX3 / capacity * R;
        Y = LY3 / capacity * R;
        Z = LZ2 / capacity * R;

        if (considerFocalLength) {
          const focalLength = displaySize * focalLengthPercentage;
          const focalCofficient = 1 / Math.abs((focalLength - Z) / focalLength);
          [X, Y] = [X * focalCofficient, Y * focalCofficient];
        }

        return { X, Y, Z };
      };

      const calculateRelativeVector = (basePos, meshPos, z) => {
        const LRZ = Math.sin(lightX);
        const LLZ = Math.cos(lightX);
        const LLX = Math.sin(lightY) * LRZ;
        const LLY = Math.cos(lightY) * LRZ;
        const LRX = Math.pow(LLY * LLY + LLZ * LLZ, 1 / 2);
        const LRY = Math.pow(LLX * LLX + LLZ * LLZ, 1 / 2);
        const LTX = LRX > 0 ? (Math.acos(LLZ / LRX) * (LLY > 0 ? 1 : -1)) : 0;
        const LTY = LRY > 0 ? (Math.acos(LLZ / LRY) * (LLX > 0 ? 1 : -1)) : 0;

        const MLX0 = meshPos.X - basePos.X;
        const MLY0 = meshPos.Y - basePos.Y;
        const MLZ0 = meshPos.Z - basePos.Z;
        const MRX0 = Math.pow(MLY0 * MLY0 + MLZ0 * MLZ0, 1 / 2);
        const MTX0 = MRX0 > 0 ? (Math.acos(MLZ0 / MRX0) * (MLY0 > 0 ? 1 : -1)) : 0;
        const MTX1 = MTX0 + LTX;
        const MLZ1 = Math.cos(MTX1) * MRX0;
        const MLY1 = Math.sin(MTX1) * MRX0;
        const MRY1 = Math.pow(MLX0 * MLX0 + MLZ1 * MLZ1, 1 / 2);
        const MTY1 = MRY1 > 0 ? (Math.acos(MLZ1 / MRY1) * (MLX0 > 0 ? 1 : -1)) : 0;
        const MTY2 = MTY1 + LTY;
        const MLX2 = Math.sin(MTY2) * MRY1;
        const MLZ2 = Math.cos(MTY2) * MRY1;
        const MRZ2 = Math.pow(MLX2 * MLX2 + MLY1 * MLY1, 1 / 2);
        const MRO2 = Math.pow(MLZ2 * MLZ2 + MRZ2 * MRZ2, 1 / 2);
        const MTO2 = MRO2 > 0 ? Math.acos(MLZ2 / MRO2) : 0;

        return Math.abs(MTO2) % (Math.PI * 2);
      };

      const calculateColor = (C, V) => {
        const CD = C.map((C0, i) => {
          const C1 = V < 1 / 2
            ? Math.round(C0 + (255 - C0) * (1 - V * 2))
            : Math.round(C0 * (1 / 2 + 1 - V));

          return (C1 < 16 ? '0' : '') + C1.toString(16);
        });

        return `#${CD.join('')}`;
      };

      const output = () => {
        if (moveSwitch === true) {
          move();
          slide();
        }

        const surfaces = [];

        [
          ...blocks,
          ...(block ? block.P.map((p) => ({ P: p, C: block.C })) : [])
        ].forEach(({ P, C }) => {
          const [LX1, LX2] = [P.X + 1 / 2, P.X - 1 / 2];
          const [LY1, LY2] = [P.Y + 1 / 2, P.Y - 1 / 2];
          const [LZ1, LZ2] = [P.Z + 1 / 2, P.Z - 1 / 2];
          const pointPoses = [
            { X: LX1, Y: LY1, Z: LZ1 }, // 左上前
            { X: LX2, Y: LY1, Z: LZ1 }, // 右上前
            { X: LX1, Y: LY2, Z: LZ1 }, // 左下前
            { X: LX2, Y: LY2, Z: LZ1 }, // 右下前
            { X: LX1, Y: LY1, Z: LZ2 }, // 左上後
            { X: LX2, Y: LY1, Z: LZ2 }, // 右上後
            { X: LX1, Y: LY2, Z: LZ2 }, // 左下後
            { X: LX2, Y: LY2, Z: LZ2 }, // 右下後
          ].map((pos) => calculateBlockPosition(pos, true));
          const meshPoses = [
            { X: P.X, Y: P.Y, Z: P.Z }, // 中心
            { X: P.X, Y: P.Y, Z: LZ1 }, // 正面
            { X: P.X, Y: LY1, Z: P.Z }, // 上面
            { X: P.X, Y: LY2, Z: P.Z }, // 下面
            { X: LX1, Y: P.Y, Z: P.Z }, // 左面
            { X: LX2, Y: P.Y, Z: P.Z }, // 右面
            { X: P.X, Y: P.Y, Z: LZ2 }, // 背面
          ].map((pos) => calculateBlockPosition(pos, false));
          [
            { P: [pointPoses[0], pointPoses[1], pointPoses[3], pointPoses[2]], M: meshPoses[1] },
            { P: [pointPoses[0], pointPoses[1], pointPoses[5], pointPoses[4]], M: meshPoses[2] },
            { P: [pointPoses[0], pointPoses[2], pointPoses[6], pointPoses[4]], M: meshPoses[4] },
            { P: [pointPoses[1], pointPoses[3], pointPoses[7], pointPoses[5]], M: meshPoses[5] },
            { P: [pointPoses[2], pointPoses[3], pointPoses[7], pointPoses[6]], M: meshPoses[3] },
            { P: [pointPoses[4], pointPoses[5], pointPoses[7], pointPoses[6]], M: meshPoses[6] },
          ].forEach(({ P, M }) => {
            const Z = P.reduce((res, pos) => res + pos.Z, 0);
            const V = calculateRelativeVector(meshPoses[0], M);
            surfaces.push({ P, Z, C, V });
          });
        });

        if (block) {
          const blockBase = block.P.reduce(
            (res, P) =>
              (block.D === 0 && (!(`${P.X}.${P.Y}` in res) || res[`${P.X}.${P.Y}`].V > P.Z)) ? ({ ...res, [`${P.X}.${P.Y}`]: { P, V: P.Z }}) :
              (block.D === 1 && (!(`${P.X}.${P.Z}` in res) || res[`${P.X}.${P.Z}`].V > P.Y)) ? ({ ...res, [`${P.X}.${P.Z}`]: { P, V: P.Y }}) :
              (block.D === 2 && (!(`${P.X}.${P.Y}` in res) || res[`${P.X}.${P.Y}`].V < P.Z)) ? ({ ...res, [`${P.X}.${P.Y}`]: { P, V: P.Z }}) :
              (block.D === 3 && (!(`${P.X}.${P.Z}` in res) || res[`${P.X}.${P.Z}`].V < P.Y)) ? ({ ...res, [`${P.X}.${P.Z}`]: { P, V: P.Y }}) :
              (block.D === 4 && (!(`${P.Y}.${P.Z}` in res) || res[`${P.Y}.${P.Z}`].V > P.X)) ? ({ ...res, [`${P.Y}.${P.Z}`]: { P, V: P.X }}) :
              (block.D === 5 && (!(`${P.Y}.${P.Z}` in res) || res[`${P.Y}.${P.Z}`].V < P.X)) ? ({ ...res, [`${P.Y}.${P.Z}`]: { P, V: P.X }}) :
              res,
            {}
          );

          const blocksCover = blocks.reduce(
            (res, { P }) =>
              (block.D === 0 && (!(`${P.X}.${P.Y}` in res) || res[`${P.X}.${P.Y}`] < P.Z)) ? ({ ...res, [`${P.X}.${P.Y}`]: P.Z }) :
              (block.D === 1 && (!(`${P.X}.${P.Z}` in res) || res[`${P.X}.${P.Z}`] < P.Y)) ? ({ ...res, [`${P.X}.${P.Z}`]: P.Y }) :
              (block.D === 2 && (!(`${P.X}.${P.Y}` in res) || res[`${P.X}.${P.Y}`] > P.Z)) ? ({ ...res, [`${P.X}.${P.Y}`]: P.Z }) :
              (block.D === 3 && (!(`${P.X}.${P.Z}` in res) || res[`${P.X}.${P.Z}`] > P.Y)) ? ({ ...res, [`${P.X}.${P.Z}`]: P.Y }) :
              (block.D === 4 && (!(`${P.Y}.${P.Z}` in res) || res[`${P.Y}.${P.Z}`] < P.X)) ? ({ ...res, [`${P.Y}.${P.Z}`]: P.X }) :
              (block.D === 5 && (!(`${P.Y}.${P.Z}` in res) || res[`${P.Y}.${P.Z}`] > P.X)) ? ({ ...res, [`${P.Y}.${P.Z}`]: P.X }) :
              res,
            {}
          );

          const diffBase =
            [0, 1, 4].includes(block.D)
              ? capacity + 3 + Math.min(...Object.keys(blockBase).map((code) => blockBase[code].V))
              : capacity + 3 - Math.max(...Object.keys(blockBase).map((code) => blockBase[code].V));
          const diffs = Object.keys(blockBase)
            .filter(
              (code) =>
                code in blocksCover && (
                  ([0, 1, 4].includes(block.D) && blockBase[code].V >= blocksCover[code]) ||
                  ([2, 3, 5].includes(block.D) && blockBase[code].V <= blocksCover[code])
                )
            ).map(
              (code) => Math.abs(blockBase[code].V - blocksCover[code])
            );
          const diff = Math.min(diffBase, ...diffs);

          Object.keys(blockBase).forEach((code) => {
            const { P: { X, Y, Z }, V } = blockBase[code];
            const trajectoryPoses = Array(diff).fill(null).map(
              (_, i) => (
                  Array(4).fill(null).map((_, j) =>
                    block.D === 0 ?
                      { X: X + ([0, 3].includes(j) ? 1 : -1) / 2, Y: Y + ([0, 1].includes(j) ? 1 : -1) / 2, Z: Z - i - 1 / 2 } :
                    block.D === 1 ?
                      { X: X + ([0, 3].includes(j) ? 1 : -1) / 2, Z: Z + ([0, 1].includes(j) ? 1 : -1) / 2, Y: Y - i - 1 / 2 } :
                    block.D === 2 ?
                      { X: X + ([0, 3].includes(j) ? 1 : -1) / 2, Y: Y + ([0, 1].includes(j) ? 1 : -1) / 2, Z: Z + i + 1 / 2 } :
                    block.D === 3 ?
                      { X: X + ([0, 3].includes(j) ? 1 : -1) / 2, Z: Z + ([0, 1].includes(j) ? 1 : -1) / 2, Y: Y + i + 1 / 2 } :
                    block.D === 4 ?
                      { Y: Y + ([0, 3].includes(j) ? 1 : -1) / 2, Z: Z + ([0, 1].includes(j) ? 1 : -1) / 2, X: X - i - 1 / 2 } :
                      { Y: Y + ([0, 3].includes(j) ? 1 : -1) / 2, Z: Z + ([0, 1].includes(j) ? 1 : -1) / 2, X: X + i + 1 / 2 }
                  )
              )
            ).map(
              (ps) => ps.map((p) => calculateBlockPosition(p, true))
            );

            trajectoryPoses.forEach((p1, i) => {
              if (i > 0) {
                const p0 = trajectoryPoses[i - 1];
                Array(4).fill(null).forEach((_, j) => {
                  const nextP1 = ([0, 1, 2, 3].includes(block.D) ? X : Y) + (j === 3 ? 1 : j === 1 ? -1 : 0);
                  const nextP2 = ([1, 3, 4, 5].includes(block.D) ? Z : Y) + (j === 0 ? 1 : j === 2 ? -1 : 0);
                  const nextPos = blockBase[`${nextP1}.${nextP2}`];
                  if (nextPos) {
                    if ([0, 1, 4].includes(block.D) && nextPos.V - diff <= V - i - 1) return;
                    if ([2, 3, 5].includes(block.D) && nextPos.V + diff >= V + i + 1) return;
                  }
                  const P = [p0[j], p0[(j + 1) % 4], p1[(j + 1) % 4], p1[j]];
                  const L = [];
                  const cornerPT1 = ([0, 1, 2, 3].includes(block.D) ? X : Y) + (j === 2 ? 1 : j === 0 ? -1 : 0);
                  const cornerPT2 = ([1, 3, 4, 5].includes(block.D) ? Z : Y) + (j === 3 ? 1 : j === 1 ? -1 : 0);
                  const cornerPN1 = ([0, 1, 2, 3].includes(block.D) ? X : Y) + ([0, 1].includes(j) ? -1 : 1);
                  const cornerPN2 = ([1, 3, 4, 5].includes(block.D) ? Z : Y) + ([1, 2].includes(j) ? -1 : 1);
                  const cornerPosT = blockBase[`${cornerPT1}.${cornerPT2}`];
                  const cornerPosN = blockBase[`${cornerPN1}.${cornerPN2}`];
                  if (
                    (
                      !cornerPosT ||
                      ([0, 1, 4].includes(block.D) && cornerPosT.V - diff > V - i - 1) ||
                      ([2, 3, 5].includes(block.D) && cornerPosT.V + diff < V + i + 1)
                    ) || (
                      cornerPosN && (
                        ([0, 1, 4].includes(block.D) && cornerPosN.V > V - i && cornerPosN.V - diff <= V - i - 1) ||
                        ([2, 3, 5].includes(block.D) && cornerPosN.V < V + i && cornerPosN.V + diff >= V + i + 1)
                      )
                    )
                  ) {
                    L.push([p0[(j + 1) % 4], p1[(j + 1) % 4]]);
                  }
                  surfaces.push({ P, L, Z: P.reduce((z, p) => z + p.Z, 0) });
                });
              }
              if (i === diff - 1) {
                surfaces.push({ P: p1, Z: p1.reduce((z, p) => z + p.Z, 0) });
              }
            });
          });
        }

        surfaces.sort((A, B) => A.Z - B.Z);

        const framePoses = [
          { X: capacity, Y: capacity, Z: capacity },
          { X: capacity * -1, Y: capacity, Z: capacity },
          { X: capacity, Y: capacity * -1, Z: capacity },
          { X: capacity * -1, Y: capacity * -1, Z: capacity },
          { X: capacity, Y: capacity, Z: capacity * -1 },
          { X: capacity * -1, Y: capacity, Z: capacity * -1 },
          { X: capacity, Y: capacity * -1, Z: capacity * -1 },
          { X: capacity * -1, Y: capacity * -1, Z: capacity * -1 },
        ].map((pos) => calculateBlockPosition(pos, true));
        const frameLines = [
          [framePoses[0], framePoses[1]],
          [framePoses[0], framePoses[2]],
          [framePoses[0], framePoses[4]],
          [framePoses[3], framePoses[1]],
          [framePoses[3], framePoses[2]],
          [framePoses[3], framePoses[7]],
          [framePoses[5], framePoses[1]],
          [framePoses[5], framePoses[4]],
          [framePoses[5], framePoses[7]],
          [framePoses[6], framePoses[2]],
          [framePoses[6], framePoses[4]],
          [framePoses[6], framePoses[7]],
        ].sort((A, B) => A[0].Z + A[1].Z - B[0].Z - B[1].Z);

        displayContext.clearRect(0, 0, displaySize, displaySize);

        displayContext.strokeStyle = '#aaddff88';
        Array(6).fill(null).forEach((_, i) => {
          displayContext.beginPath();
          displayContext.moveTo(displayRadius + frameLines[i][0].X, displayRadius + frameLines[i][0].Y);
          displayContext.lineTo(displayRadius + frameLines[i][1].X, displayRadius + frameLines[i][1].Y);
          displayContext.stroke();
        });

        surfaces.forEach((mesh, n) => {
          if (!mesh.C) {
            if (mesh.L) {
              displayContext.fillStyle = '#ff88aa22';
              displayContext.strokeStyle = '#ff88aa44';
              displayContext.beginPath();
              mesh.P.forEach(({ X, Y, Z }, j) => {
                j === 0
                  ? displayContext.moveTo(displayRadius + X, displayRadius + Y)
                  : displayContext.lineTo(displayRadius + X, displayRadius + Y);
              });
              displayContext.closePath();
              displayContext.fill();

              mesh.L.forEach((L) => {
                displayContext.beginPath();
                displayContext.moveTo(displayRadius + L[0].X, displayRadius + L[0].Y);
                displayContext.lineTo(displayRadius + L[1].X, displayRadius + L[1].Y);
                displayContext.stroke();
              });
            } else {
              displayContext.fillStyle = '#ff88aa66';
              displayContext.strokeStyle = '#ff88aa88';
              displayContext.beginPath();
              mesh.P.forEach(({ X, Y, Z }, j) => {
                j === 0
                  ? displayContext.moveTo(displayRadius + X, displayRadius + Y)
                  : displayContext.lineTo(displayRadius + X, displayRadius + Y);
              });
              displayContext.closePath();
              displayContext.fill();
            }

            return;
          }

          // displayContext.fillStyle = calculateColor(mesh.C, mesh.V / Math.PI, mesh.V, mesh.z) + '88';
          // displayContext.strokeStyle = calculateColor(mesh.C, mesh.V / Math.PI) + 'aa';
          displayContext.fillStyle = calculateColor(mesh.C, mesh.V / Math.PI, mesh.V, mesh.z) + 'bb';
          displayContext.strokeStyle = calculateColor(mesh.C, mesh.V / Math.PI) + 'cc';
          displayContext.beginPath();
          mesh.P.forEach(({ X, Y }, j) => {
            j === 0
              ? displayContext.moveTo(displayRadius + X, displayRadius + Y)
              : displayContext.lineTo(displayRadius + X, displayRadius + Y);
          });
          displayContext.closePath();
          displayContext.fill();
          displayContext.stroke();
        });

        displayContext.strokeStyle = '#aaddffaa';
        Array(6).fill(null).forEach((_, i) => {
          displayContext.beginPath();
          displayContext.moveTo(displayRadius + frameLines[6 + i][0].X, displayRadius + frameLines[6 + i][0].Y);
          displayContext.lineTo(displayRadius + frameLines[6 + i][1].X, displayRadius + frameLines[6 + i][1].Y);
          displayContext.stroke();
        });

        if (block) {
          const { D, S: { X, Y, Z } } = block;
          const { X: SX, Y: SY, Z: SZ } = calculateBlockPosition({ X, Y, Z }, true);
          const PS = (
            D === 0 ? [
              [{ X, Y: Y + 5, Z }, { X: X + 1, Y: Y + 4, Z }, { X: X - 1, Y: Y + 4, Z }],
              [{ X: X - 5, Y, Z }, { X: X - 4, Y: Y + 1, Z }, { X: X - 4, Y: Y - 1, Z }],
              [{ X, Y: Y - 5, Z }, { X: X + 1, Y: Y - 4, Z }, { X: X - 1, Y: Y - 4, Z }],
              [{ X: X + 5, Y, Z }, { X: X + 4, Y: Y + 1, Z }, { X: X + 4, Y: Y - 1, Z }],
            ] :
            D === 1 ? [
              [{ X, Y, Z: Z - 5 }, { X: X + 1, Y, Z: Z - 4 }, { X: X - 1, Y, Z: Z - 4 }],
              [{ X: X - 5, Y, Z }, { X: X - 4, Y, Z: Z + 1 }, { X: X - 4, Y, Z: Z - 1 }],
              [{ X, Y, Z: Z + 5 }, { X: X + 1, Y, Z: Z + 4 }, { X: X - 1, Y, Z: Z + 4 }],
              [{ X: X + 5, Y, Z }, { X: X + 4, Y, Z: Z + 1 }, { X: X + 4, Y, Z: Z - 1 }],
            ] :
            D === 2 ? [
              [{ X, Y: Y - 5, Z }, { X: X - 1, Y: Y - 4, Z }, { X: X + 1, Y: Y - 4, Z }],
              [{ X: X + 5, Y, Z }, { X: X + 4, Y: Y - 1, Z }, { X: X + 4, Y: Y + 1, Z }],
              [{ X, Y: Y + 5, Z }, { X: X - 1, Y: Y + 4, Z }, { X: X + 1, Y: Y + 4, Z }],
              [{ X: X - 5, Y, Z }, { X: X - 4, Y: Y - 1, Z }, { X: X - 4, Y: Y + 1, Z }],
            ] :
            D === 3 ? [
              [{ X, Y, Z: Z + 5 }, { X: X - 1, Y, Z: Z + 4 }, { X: X + 1, Y, Z: Z + 4 }],
              [{ X: X + 5, Y, Z }, { X: X + 4, Y, Z: Z - 1 }, { X: X + 4, Y, Z: Z + 1 }],
              [{ X, Y, Z: Z - 5 }, { X: X - 1, Y, Z: Z - 4 }, { X: X + 1, Y, Z: Z - 4 }],
              [{ X: X - 5, Y, Z }, { X: X - 4, Y, Z: Z - 1 }, { X: X - 4, Y, Z: Z + 1 }],
            ] :
            D === 4 ? [
              [{ X, Y: Y + 5, Z }, { X, Y: Y + 4, Z: Z + 1 }, { X, Y: Y + 4, Z: Z - 1 }],
              [{ X, Y, Z: Z + 5 }, { X, Y: Y + 1, Z: Z + 4 }, { X, Y: Y - 1, Z: Z + 4 }],
              [{ X, Y: Y - 5, Z }, { X, Y: Y - 4, Z: Z + 1 }, { X, Y: Y - 4, Z: Z - 1 }],
              [{ X, Y, Z: Z - 5 }, { X, Y: Y + 1, Z: Z - 4 }, { X, Y: Y - 1, Z: Z - 4 }],
            ] :
            [
              [{ X, Y: Y + 5, Z }, { X, Y: Y + 4, Z: Z + 1 }, { X, Y: Y + 4, Z: Z - 1 }],
              [{ X, Y, Z: Z - 5 }, { X, Y: Y + 1, Z: Z - 4 }, { X, Y: Y - 1, Z: Z - 4 }],
              [{ X, Y: Y - 5, Z }, { X, Y: Y - 4, Z: Z + 1 }, { X, Y: Y - 4, Z: Z - 1 }],
              [{ X, Y, Z: Z + 5 }, { X, Y: Y + 1, Z: Z + 4 }, { X, Y: Y - 1, Z: Z + 4 }],
            ]
          ).map(
            (P) => (P.map((p) => calculateBlockPosition(p, true)))
          );
          const CS = ['#00aa00', '#0000ff', '#ffff00', '#ff0000'];
          const [PUI] = PS.reduce(([I, T0], P, i) => {
            const X1 = P[0].X - SX;
            const Y1 = P[0].Y - SY;
            const L1 = Math.pow(X1 * X1 + Y1 * Y1, 1 / 2);
            const T1 = L1 > 0 ? Math.abs(Math.acos(Y1 / L1)) : 0;

            return T0 && T0 < T1 ? [I, T0] : [i, T1];
          }, [0, null]);
          const [PLI] = [(PUI + 1) % 4, (PUI + 3) % 4].reduce(([I, T0], i) => {
            const P1 = PS[i];
            const X1 = P1[0].X - SX;
            const Y1 = P1[0].Y - SY;
            const L1 = Math.pow(X1 * X1 + Y1 * Y1, 1 / 2);
            const T1 = L1 > 0 ? Math.abs(Math.acos(X1 / L1)) : 0;

            return T0 && T0 < T1 ? [I, T0] : [i, T1];
          }, [(PUI + 1) % 4, null]);
          directionMap.U = PUI;
          directionMap.L = PLI;
          directionMap.D = (PUI + 2) % 4;
          directionMap.R = (PLI + 2) % 4;
          ['U', 'R', 'D', 'L'].forEach((D, i) => {
            PS[directionMap[D]] = { P: PS[directionMap[D]], C: CS[i] };
          });

          PS.forEach(({ P, C }) => {
            displayContext.fillStyle = C + '88';
            displayContext.strokeStyle = C + 'aa';
            displayContext.beginPath();
            P.forEach(({ X, Y }, j) => {
              j === 0
                ? displayContext.moveTo(displayRadius + X, displayRadius + Y)
                : displayContext.lineTo(displayRadius + X, displayRadius + Y);
            });
            displayContext.closePath();
            displayContext.fill();
            displayContext.stroke();
          });
        }
      };

      const move = () => {
        positionAxisX = axisX;
        positionAxisY = axisY;
        positionAxisL = axisL;

        if (moveType === 'vector') {
          const diffX = latestMoveX - latestBaseX;
          const diffY = latestMoveY - latestBaseY;
          const diffL = Math.pow(diffX * diffX + diffY * diffY, 1 / 2);
          const diffR = Math.max(diffL, displayRadius / 100);

          if (diffL > 0) {
            momentAxisY = Math.acos(diffY / diffL) * (diffX >= 0 ? 1 : -1) + Math.PI / 2;
          }
          momentAxisX = Math.PI / 2;
          momentAxisL = 0;
          diffAxisL = diffR > 0 ? Math.asin(diffR / displayRadius) : 0;
        } else {
          const X1 = latestBaseX - displayRadius;
          const Y1 = latestBaseY - displayRadius;
          const X2 = latestMoveX - displayRadius;
          const Y2 = latestMoveY - displayRadius;
          const L1 = Math.pow(X1 * X1 + Y1 * Y1, 1 / 2);
          const L2 = Math.pow(X2 * X2 + Y2 * Y2, 1 / 2);
          const T1 = L1 > 0 ? Math.acos(Y1 / L1) * (X1 >= 0 ? 1 : -1) : 0;
          const T2 = L2 > 0 ? Math.acos(Y2 / L2) * (X2 >= 0 ? 1 : -1) : 0;

          momentAxisX = 0;
          momentAxisY = 0;
          momentAxisL = 0;
          diffAxisL = T2 - T1;
        }

        latestBaseX = latestMoveX;
        latestBaseY = latestMoveY;
      };

      const slide = () => {
        momentAxisL += diffAxisL;

        const RZ0 = Math.sin(positionAxisX); // Z面上の半径
        const LZ0 = Math.cos(positionAxisX); // Z軸上の中心点との距離
        const TZ1 = positionAxisY - momentAxisY; // 回転軸に対するZ面上の相対角度
        const LX1 = Math.sin(TZ1) * RZ0; // 回転軸に対するX軸上の相対距離
        const LY1 = Math.cos(TZ1) * RZ0; // 回転軸に対するY軸上の相対距離
        const RX1 = Math.pow(LY1 * LY1 + LZ0 * LZ0, 1 / 2);
        const TX1 = RX1 > 0 ? Math.acos(LZ0 / RX1) * (LY1 >= 0 ? 1 : -1) : 0;
        const TX2 = TX1 - momentAxisX; // 回転軸に対するX面上の相対角度
        const LY2 = Math.sin(TX2) * RX1;
        const LZ2 = Math.cos(TX2) * RX1;
        const RZ2 = Math.pow(LX1 * LX1 + LY2 * LY2, 1 / 2);
        const TZ2 = RZ2 > 0 ? Math.acos(LY2 / RZ2) * (LX1 >= 0 ? 1 : -1) : 0;
        const TZ3 = TZ2 + momentAxisL; // 回転角度に対するZ面上の相対角度
        const LX3 = Math.sin(TZ3) * RZ2;
        const LY3 = Math.cos(TZ3) * RZ2;
        const RX3 = Math.pow(LY3 * LY3 + LZ2 * LZ2, 1 / 2);
        const TX3 = RX3 > 0 ? Math.acos(LZ2 / RX3) * (LY3 >= 0 ? 1 : -1) : 0;
        const TX4 = TX3 + momentAxisX;
        const LY4 = Math.sin(TX4) * RX3;
        const LZ4 = Math.cos(TX4) * RX3;
        const RZ4 = Math.pow(LX3 * LX3 + LY4 * LY4, 1 / 2);
        const TZ4 = RZ4 > 0 ? Math.acos(LY4 / RZ4) * (LX3 >= 0 ? 1 : -1) : 0;
        const TZ5 = TZ4 + momentAxisY;
        const RX5 = Math.pow(RZ4 * RZ4 + LZ4 * LZ4, 1 / 2);
        const TX5 = RX5 > 0 ? Math.acos(LZ4 / RX5) : 0;

        const L_LX0 = Math.sin(positionAxisL);
        const L_LY0 = Math.cos(positionAxisL) * Math.cos(positionAxisX);
        const L_LZ0 = Math.cos(positionAxisL) * Math.sin(positionAxisX) * -1;
        const L_RZ0 = Math.pow(L_LX0 * L_LX0 + L_LY0 * L_LY0, 1 / 2);
        const L_TZ0 = L_RZ0 > 0 ? Math.acos(L_LY0 / L_RZ0) * (L_LX0 >= 0 ? 1 : -1) : 0;
        const L_TZ1 = L_TZ0 + positionAxisY - momentAxisY;
        const L_LX1 = Math.sin(L_TZ1) * L_RZ0;
        const L_LY1 = Math.cos(L_TZ1) * L_RZ0;
        const L_RX1 = Math.pow(L_LY1 * L_LY1 + L_LZ0 * L_LZ0, 1 / 2);
        const L_TX1 = L_RX1 > 0 ? Math.acos(L_LZ0 / L_RX1) * (L_LY1 >= 0 ? 1 : -1) : 0;
        const L_TX2 = L_TX1 - momentAxisX;
        const L_LY2 = Math.sin(L_TX2) * L_RX1;
        const L_LZ2 = Math.cos(L_TX2) * L_RX1;
        const L_RZ2 = Math.pow(L_LX1 * L_LX1 + L_LY2 * L_LY2, 1 / 2);
        const L_TZ2 = L_RZ2 > 0 ? Math.acos(L_LY2 / L_RZ2) * (L_LX1 >= 0 ? 1 : -1) : 0;
        const L_TZ3 = L_TZ2 + momentAxisL;
        const L_LX3 = Math.sin(L_TZ3) * L_RZ2;
        const L_LY3 = Math.cos(L_TZ3) * L_RZ2;
        const L_RX3 = Math.pow(L_LY3 * L_LY3 + L_LZ2 * L_LZ2, 1 / 2);
        const L_TX3 = L_RX3 > 0 ? Math.acos(L_LZ2 / L_RX3) * (L_LY3 >= 0 ? 1 : -1) : 0;
        const L_TX4 = L_TX3 + momentAxisX;
        const L_LY4 = Math.sin(L_TX4) * L_RX3;
        const L_LZ4 = Math.cos(L_TX4) * L_RX3;
        const L_RZ4 = Math.pow(L_LX3 * L_LX3 + L_LY4 * L_LY4, 1 / 2);
        const L_TZ4 = L_RZ4 > 0 ? Math.acos(L_LY4 / L_RZ4) * (L_LX3 >= 0 ? 1 : -1) : 0;
        const L_TZ5 = L_TZ4 - TZ4;
        const L_LX5 = Math.sin(L_TZ5) * L_RZ4;
        const L_LY5 = Math.cos(L_TZ5) * L_RZ4;
        const L_RX5 = Math.pow(L_LY5 * L_LY5 + L_LZ4 * L_LZ4, 1 / 2);
        const L_TX5 = L_RX5 > 0 ? Math.acos(L_LZ4 / L_RX5) * (L_LY5 >= 0 ? 1 : -1) : 0;
        const L_TX6 = L_TX5 - TX5;
        const L_LY6 = Math.sin(L_TX6) * L_RX5;
        const L_RZ6 = Math.pow(L_LX5 * L_LX5 + L_LY6 * L_LY6, 1 / 2);
        const L_TZ6 = L_RZ6 > 0 ? Math.acos(L_LY6 / L_RZ6) * (L_LX5 >= 0 ? 1 : -1) : 0;

        axisX = TX5;
        axisY = TZ5;
        axisL = L_TZ6;
      };

      const summonBlock = () => {
        const D = Math.floor(Math.random() * 6);
        const N = Math.floor(Math.random() * blockFormations.length);
        const B = blockFormations[N];
        const S = {
          X: (D === 4 ? capacity : D === 5 ? (capacity * -1) : 0),
          Y: (D === 1 ? capacity : D === 3 ? (capacity * -1) : 0),
          Z: (D === 0 ? capacity : D === 2 ? (capacity * -1) : 0),
        };
        const P = B.P.map(([X, Y]) => ({ X: S.X + X, Y: S.Y + Y, Z: S.Z }));

        block = { P, C: B.C, D, S };

        rotateBlock(
          Math.floor(Math.random() * 4),
          Math.floor(Math.random() * 4),
          Math.floor(Math.random() * 4),
        );
      };

      const rotateBlock = (RZ, RX, RY) => {
        block.P.forEach(({ X, Y, Z }, i) => {
          [X, Y, Z] = [X - block.S.X, Y - block.S.Y, Z - block.S.Z];
          [X, Y] = RZ === 1 ? [Y, X * -1] : RZ === 2 ? [X * -1, Y * -1] : RZ === 3 ? [Y * -1, X] : [X, Y];
          [Y, Z] = RX === 1 ? [Z, Y * -1] : RX === 2 ? [Y * -1, Z * -1] : RX === 3 ? [Z * -1, Y] : [Y, Z];
          [X, Z] = RY === 1 ? [Z, X * -1] : RY === 2 ? [X * -1, Z * -1] : RY === 3 ? [Z * -1, X] : [X, Z];
          [block.P[i].X, block.P[i].Y, block.P[i].Z] = [X + block.S.X, Y + block.S.Y, Z + block.S.Z];
        });
      };

      const slideBlock = (direction) => {
        const [P, [S]] = [block.P, [block.S]].map(
          (ps) => ps.map((p) => ({
            ...p,
            X: p.X + (direction === 4 ? 1 : direction === 5 ? -1 : 0),
            Y: p.Y + (direction === 1 ? 1 : direction === 3 ? -1 : 0),
            Z: p.Z + (direction === 0 ? 1 : direction === 2 ? -1 : 0),
          }))
        );

        if (P.find(
            (p) => blocks.find(
              (b) => b.P.X === p.X && b.P.Y === p.Y && b.P.Z === p.Z
            )
        )) {
          return -1;
        }

        if (P.find(
          (p) => Math.abs(p.X) > capacity + 2 || Math.abs(p.Y) > capacity + 2 || Math.abs(p.Z) > capacity + 2
        )) {
          return -2;
        }

        block.P = P;
        block.S = S;

        return 0;
      };

      const inspectBlocks = () => {
        const afterBlocks = [{ P: { X:  0, Y:  0, Z:  0 }, C: [200, 255, 248] }];
        // console.log(blocks);
        try {
          Array(capacity).fill(null).forEach((_1, i) => {
            const layerBlocks = [];

            Array(6).fill(null).forEach((_2, j) => {
              const [PK1, PS1, PL1, PK2, PS2, PL2, PK3, P3] = [
                ['X', (i + 1) * -1, (i + 1) * 2 + 1, 'Y', (i + 1) * -1, (i + 1) * 2 + 1, 'Z', i + 1],
                ['X', (i + 1) * -1, (i + 1) * 2 + 1, 'Z', i * -1, (i + 1) * 2 - 1, 'Y', i + 1],
                ['X', (i + 1) * -1, (i + 1) * 2 + 1, 'Y', (i + 1) * -1, (i + 1) * 2 + 1, 'Z', i * -1 - 1],
                ['X', (i + 1) * -1, (i + 1) * 2 + 1, 'Z', i * -1, (i + 1) * 2 - 1, 'Y', i  * -1 - 1],
                ['Y', i * -1, (i + 1) * 2 - 1, 'Z', i * -1, (i + 1) * 2 - 1, 'X', i + 1],
                ['Y', i * -1, (i + 1) * 2 - 1, 'Z', i * -1, (i + 1) * 2 - 1, 'X', i * -1 - 1],
              ][j];
              // console.log(PK1, PS1, PL1, PK2, PS2, PL2, PK3, P3);
              Array(PL1).fill(null).forEach((_31, PI1) => {
                const P1 = PS1 + PI1;
                Array(PL2).fill(null).forEach((_32, PI2) => {
                  const P2 = PS2 + PI2;
                  const P = blocks.find(({ P: p }) => p[PK1] === P1 && p[PK2] === P2 && p[PK3] === P3);
                  if (P) layerBlocks.push(P);
                });
              });
            });

            if (layerBlocks.length === 0) {
              throw null;
            } else if (layerBlocks.length === Math.pow((i + 1) * 2 + 1, 3) - Math.pow(i * 2 + 1, 3)) {
              score += Math.pow(10, i + 1);
            } else {
              layerBlocks.forEach((b) => {
                afterBlocks.push(b);
              });
            }
          });
        } catch (_e) {
        }

        if (afterBlocks.length < blocks.length) {
          // 空白の穴埋め
          let blockChain = { '0.0.0': { P: [afterBlocks[0]], BP: [] } };
          const blockRelations = { '0.0.0': '0.0.0' };
          const [K1, K2, K3, S3, V3] = [
            ['X', 'Y', 'Z', capacity, -1],
            ['X', 'Z', 'Y', capacity, -1],
            ['X', 'Y', 'Z', capacity * -1, 1],
            ['X', 'Z', 'Y', capacity * -1, 1],
            ['Y', 'Z', 'X', capacity, -1],
            ['Y', 'Z', 'X', capacity * -1, 1],
          ][block.D];
          afterBlocks.forEach((BA) => {
            const { P: { [K1]: P1, [K2]: P2, [K3]: P3 } } = BA;
            const KA = `${P1}.${P2}.${P3}`;
            let isBase = false;

            [[P1 + 1, P2, P3], [P1, P2 + 1, P3], [P1, P2, P3 + V3]].forEach(([NP1, NP2, NP3], l) => {
              const IB = afterBlocks.findIndex(({ P }) => P[K1] === NP1 && P[K2] === NP2 && P[K3] === NP3);
              if (IB >= 0) {
                const BB = afterBlocks[IB];
                const KB = `${NP1}.${NP2}.${NP3}`;
                if (blockRelations[KA] && blockRelations[KB]) {
                  const { [KA]: KC, [KB]: KD } = blockRelations;
                  const [KE, KF] = KA === '0.0.0' ? [KC, KD] : [KD, KC];
                  const { [KF]: { P: BF }, ...afterBlockChain } = blockChain;
                  BF.forEach((b) => {
if (!afterBlockChain[KE]) {
console.log(`KA:${KA}
KB:${KB}
KC:${KC}
KD:${KD}
KE:${KE}
KF:${KF}`, blockRelations, blockChain);
}
                    afterBlockChain[KE].P.push(b);
                    blockRelations[`${b.P[K1]}.${b.P[K2]}.${b.P[K3]}`] = KE;
                  });
                  blockChain = afterBlockChain;
                } else if (blockRelations[KA]) {
                  blockChain[blockRelations[KA]].P.push(BA);
                  blockRelations[KB] = blockRelations[KA];
                } else if (blockRelations[KB]) {
                  blockChain[blockRelations[KB]].P.push(BB);
                  blockRelations[KA] = blockRelations[KB];
                } else {
                  blockChain[KA] = { P: [BA, BB], BP: [] };
                  blockRelations[KA] = KA;
                  blockRelations[KB] = KA;
                }
              } else if (l === 2) {
                isBase = true;
              }
            });

            if (!blockRelations[KA]) {
              blockRelations[KA] = KA;
              blockChain[KA] = { P: [BA], BP: [] };
            }
            if (isBase) {
              blockChain[blockRelations[KA]].BP.push(BA);
            }
          });

          let { '0.0.0': coreChain, ...otherChain } = blockChain;
          const otherCodes = Object.keys(otherChain);

          try {
            Array(otherCodes.length).fill(null).forEach((_) => {
              const coreCovers = {};
              coreChain.P.forEach(({ P: { [K1]: P1, [K2]: P2, [K3]: P3 } }) => {
                const K = `${P1}.${P2}`;
                if (!coreCovers.includes(K)) coreCovers[K] = [];
                if (!afterBlocks.find(({ P: {  [K1]: NP1, [K2]: NP2, [K3]: NP3 } }) => NP1 === P1 && NP2 === P2 && NP3 === P3 - V3)) {
                  coreCovers[K],push(P3);
                }
              });

              const diffParam = otherCodes.reduce((res, code) => {
                const { P, BP } = otherChain[code];
                BP.forEach(({ P: { [K1]: P1, [K2]: P2, [K3]: P3 } }) => {
                  const K = `${P1}.${P2}`;
                  if (coreCovers[K]) {
                    coreCovers[K].forEach((CP3) => {
                      const diff = CP3 * V3 - P3 * V3;
                      if (diff > 0 && diff < minDiff) {
                        res = { C: code, D: diff };
                      }
                    });
                  }
                });

                return res;
              }, { C: null, D: Infinity });

              if (!diffParam.C) throw null;

              otherCodes.forEach((code) => {
                otherChain[code].P.forEach((P) => {
                  P[K3] += V3 * diffParam.D;
                });
              });

              const { [diffParam.C]: targetChain, ...restChain } = otherChain;
              otherChain = restChain;

              targetChain.P.forEach((P) => {
                coreChain.P.push(P);
              });
            });
          } catch (_e) {
          }

          blocks = coreChain.P;
        }
      };

      const animate = () => {
        if (!block) {
          summonBlock();
          output();
        } else if (time > 0 && time % 50 === 0) {
          const slidedResult = slideBlock([2, 3, 0, 1, 5, 4][block.D]);

          if (slidedResult === -1) {
            block.P.forEach((p) => {
              blocks.push({ P: { ...p }, C: block.C });
            });
            inspectBlocks();
            block = null;
            time = 0;
          } else if (slidedResult === -2) {
            block = null;
            time = 0;
          }

          output();
        }

        // console.log(ka(axisX), ka(axisY), ka(axisL));

        if (animationSwitch) {
          time ++;
          setTimeout(animate, 25);
        }
      };

      const startAnimation = () => {
        animationSwitch = true;
        animate();
      };

      const stopAnimation = () => {
        animationSwitch = false;
      };

      const getMeterParams = () => {
        const meterRect = meter.getBoundingClientRect();
        const meterHandleRect = meterHandle.getBoundingClientRect();

        return {
          left: meterRect.left + meterHandleRect.width / 2,
          right: meterRect.left + meterRect.width - meterHandleRect.width / 2,
        };
      };

      const setMeterPosition = (percentage) => {
        const { left, right } = getMeterParams();
        meterHandle.style.left = `${Math.floor((right - left) * percentage)}px`;
      };

      const setFocalLengthSwitch = (operate, clientX) => {
        focalLengthSwitch = operate;
        if (operate === false) return;

        const meterHandleRect = meterHandle.getBoundingClientRect();
        if (clientX >= meterHandleRect.left && clientX <= meterHandleRect.left + meterHandleRect.width) {
          meterHandleDiffX = clientX - (meterHandleRect.left + meterHandleRect.width / 2);
        } else {
          meterHandleDiffX = 0;
          setFocalLength(clientX);
        }
      };

      const setFocalLength = (clientX) => {
        const { left, right } = getMeterParams();
        let percentage = (clientX - meterHandleDiffX - left) / (right - left);
        if (percentage < 0) percentage = 0;
        if (percentage > 1) percentage = 1;
        setMeterPosition(percentage);
        focalLengthPercentage = 1 + 1 * percentage;

        output();
      };

      const getClientPosition = (event) => ({
        X: event.clientX !== undefined ? event.clientX : event.changedTouches[0].clientX,
        Y: event.clientY !== undefined ? event.clientY : event.changedTouches[0].clientY,
      });

      const displayOnpointerdown = (event) => {
        if (moveSwitch === true || focalLengthSwitch === true) return;

        const { X, Y } = getClientPosition(event);

        moveSwitch = true;
        latestMoveX = X;
        latestMoveY = Y;
        latestBaseX = X;
        latestBaseY = Y;

        const displayRect = display.getBoundingClientRect();
        const relativeDiffX = X - displayRect.left - displayRadius;
        const relativeDiffY = Y - displayRect.top - displayRadius;
        const relativeDiffRadius = Math.pow(relativeDiffX * relativeDiffX + relativeDiffY * relativeDiffY, 1 / 2);
        moveType = relativeDiffRadius <= vectorSlideRadius ? 'vector' : 'rotate';
      };

      const documentMousemove = (event) => {
        const { X, Y } = getClientPosition(event);

        if (moveSwitch === true) {
          latestMoveX = X;
          latestMoveY = Y;
          output();
          latestBaseX = X;
          latestBaseY = Y;
        } else if (focalLengthSwitch) {
          setFocalLength(X);
        }
      };

      document.onpointerup = (event) => {
        if (moveSwitch === true) {
          moveSwitch = false;

          const { X, Y } = getClientPosition(event);
          latestMoveX = X;
          latestMoveY = Y;
        }

        setFocalLengthSwitch(false);
      };

      document.onkeydown = (event) => {
        switch (event.code) {
          case 'Enter':
            if (animationSwitch === false) {
              startAnimation();
            } else {
              stopAnimation();
            }

            break;
          case 'ShiftLeft':
          case 'ShiftRight':
            rotationSwitch = true;
            break;

          case 'ArrowUp':
          case 'ArrowRight':
          case 'ArrowDown':
          case 'ArrowLeft':
            const key = keyMap[event.code];
            const index = directionMap[key];
            if (rotationSwitch) {
              let [ZR, ZX, ZY] = [0, 0, 0];
              const { U, L } = directionMap;

              if (block.D === 0) {
                ZX = [0, 2].includes(index) ? (((key === 'U' && L === 1) || (key === 'R' && U === 1) || (key === 'D' && L === 3) || (key === 'L' && U === 3)) ? 1 : 3) : 0;
                ZY = [1, 3].includes(index) ? (((key === 'U' && L === 0) || (key === 'R' && U === 0) || (key === 'D' && L === 2) || (key === 'L' && U === 2)) ? 1 : 3) : 0;
              }
              if (block.D === 2) {
                ZX = [0, 2].includes(index) ? (((key === 'U' && L === 3) || (key === 'R' && U === 3) || (key === 'D' && L === 1) || (key === 'L' && U === 1)) ? 1 : 3) : 0;
                ZY = [1, 3].includes(index) ? (((key === 'U' && L === 2) || (key === 'R' && U === 2) || (key === 'D' && L === 0) || (key === 'L' && U === 0)) ? 1 : 3) : 0;
              }
              if (block.D === 1) {
                ZX = [0, 2].includes(index) ? (((key === 'U' && L === 1) || (key === 'R' && U === 1) || (key === 'D' && L === 3) || (key === 'L' && U === 3)) ? 1 : 3) : 0;
                ZR = [1, 3].includes(index) ? (((key === 'U' && L === 0) || (key === 'R' && U === 0) || (key === 'D' && L === 2) || (key === 'L' && U === 2)) ? 1 : 3) : 0;
              }
              if (block.D === 3) {
                ZX = [0, 2].includes(index) ? (((key === 'U' && L === 3) || (key === 'R' && U === 3) || (key === 'D' && L === 1) || (key === 'L' && U === 1)) ? 1 : 3) : 0;
                ZR = [1, 3].includes(index) ? (((key === 'U' && L === 2) || (key === 'R' && U === 2) || (key === 'D' && L === 0) || (key === 'L' && U === 0)) ? 1 : 3) : 0;
              }
              if (block.D === 4) {
                ZR = [0, 2].includes(index) ? (((key === 'U' && L === 3) || (key === 'R' && U === 3) || (key === 'D' && L === 1) || (key === 'L' && U === 1)) ? 1 : 3) : 0;
                ZY = [1, 3].includes(index) ? (((key === 'U' && L === 0) || (key === 'R' && U === 0) || (key === 'D' && L === 2) || (key === 'L' && U === 2)) ? 1 : 3) : 0;
              }
              if (block.D === 5) {
                ZR = [0, 2].includes(index) ? (((key === 'U' && L === 1) || (key === 'R' && U === 1) || (key === 'D' && L === 3) || (key === 'L' && U === 3)) ? 1 : 3) : 0;
                ZY = [1, 3].includes(index) ? (((key === 'U' && L === 0) || (key === 'R' && U === 0) || (key === 'D' && L === 2) || (key === 'L' && U === 2)) ? 1 : 3) : 0;
              }
              // console.log(`D:${block.D} DM:${JSON.stringify(directionMap)} (${ZR}.${ZX}.${ZY}) >> I:${index}`);

              rotateBlock(ZR, ZX, ZY);
            } else {
              slideBlock([
                [3, 4, 1, 5],
                [0, 4, 2, 5],
                [1, 5, 3, 4],
                [2, 5, 0, 4],
                [3, 2, 1, 0],
                [3, 0, 1, 2],
              ][block.D][index]);
            }
            output();

            break;
          case 'KeyZ':
          case 'KeyX':
          case 'KeyC':
          case 'KeyA':
          case 'KeyS':
          case 'KeyD':
            rotateBlock(...keyMap[event.code]);
            output();

            break;
          default:
            console.log(event.code);
        }
      };

      document.onkeyup = (event) => {
        switch (event.code) {
          case 'ShiftLeft':
          case 'ShiftRight':
            rotationSwitch = false;
            break;
        }
      };

      meter.onpointerdown = (event) => {
        setFocalLengthSwitch(true, getClientPosition(event).X);
      };

      if (typeof display.ontouchstart === 'object') {
        display.ontouchstart = displayOnpointerdown;
      } else {
        display.onpointerdown = displayOnpointerdown;
      }
      if (typeof document.ontouchmove === 'object') {
        document.ontouchmove = documentMousemove;
      } else {
        document.onmousemove = documentMousemove;
      }

      setMeterPosition(1 / 2);
      startAnimation();
    </script>
  </body>
</html>
