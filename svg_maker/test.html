<html>
  <head>
    <meta charset="utf-8" />
    <script>
      // // 以下の形式で定義してください。
      // // 座標定義
      // const coordinates = {
      //   // 座標キー名1: { X: 左右方向の座標, Y: 上下方向の座標, Z: 前後方向の座標 },
      //   // 座標キー名2: { X: 左右方向の座標, Y: 上下方向の座標, Z: 前後方向の座標 },
      //   // 座標キー名3: { X: 左右方向の座標, Y: 上下方向の座標, Z: 前後方向の座標 },
      //   // 座標キー名4: { X: 左右方向の座標, Y: 上下方向の座標, Z: 前後方向の座標 },
      //   // ...
      // };
      // // 面定義
      // const surfaces = {
      //   // 面キー名A: [ 座標キー名1, 座標キー名2, 座標キー名3 ], // 3点以上で面を構成
      //   // 面キー名B: [ 座標キー名1, 座標キー名4 ], // 2点で線を構成
      //   // ...
      // };
    </script>
    <script src="sample-階段.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overscroll-behavior-x: none;
        overscroll-behavior-y: none;
      }
      #contents {
        display: grid;
        grid-template-columns: auto 1fr;
        grid-template-rows: auto auto;
      }
      #form {
        grid-column: 1 / 3;
        grid-row: 1;
        display: flex;
        justify-content: flex-start;
        margin: 10px 10px 0 10px;
        padding: 5px 5px 0 5px;
        border: solid 1px #aaaaaa;
      }
      #form ul {
        list-style: none;
        margin: 0 10px 0 0;
        padding: 0;
      }
      #form li {
        display: grid;
        grid-template-columns: 100px 1fr;
        margin-bottom: 5px;
      }
      #form li p {
        margin: 0;
        display: flex;
        justify-content: flex-start;
      }
      #focal-length-meter {
        position: relative;
        height: 24px;
      }
      #focal-length-meter::before {
        content: "";
        position: absolute;
        display: block;
        width: 100%;
        height: 1px;
        top: 50%;
        border-top: solid 1px #aaaaaa;
      }
      #focal-length-meter-handle {
        position: absolute;
        top: 0;
        width: 10px;
        height: calc(100% - 2px);
        border: solid 1px #888888;
        background-color: #ffffff;
      }
      #display-wrapper {
        grid-column: 1;
        grid-row: 2;
        position: relative;
        margin: 10px 0 0 10px;
        border: solid 1px #aaaaaa;
      }
      #display,
      #auxiliary-line {
        position: absolute;
        top: 0;
        left: 0;
      }
      #monitor {
        grid-column: 2;
        grid-row: 2;
        margin: 10px 10px 0 10px;
        border: solid 1px #aa4444;
      }
    </style>
  </head>
  <body>
    <div id="contents">
      <div id="form">
        <ul>
          <li>
            <p>画面サイズ</p>
            <p>：<input type="text" id="displaySize" /></p>
          </li>
          <li>
            <p>中心点距離</p>
            <p>：<input type="text" id="focalLength" /></p>
          </li>
          <li>
            <p></p>
            <div id="focal-length-meter">
              <div id="focal-length-meter-handle"></div>
            </div>
          </li>
        </ul>
        <ul>
          <li>
            <p>正面回転角度</p>
            <p>：<input type="text" id="rotateTheta" /></p>
          </li>
          <li>
            <p>X軸傾斜角度</p>
            <p>：<input type="text" id="vectorTheta" /></p>
          </li>
          <li>
            <p>X軸回転角度</p>
            <p>
              ：<input type="text" id="lengthTheta" />&nbsp;
              <button onclick="javascript:debug();">指定</button>&nbsp;
              <button onclick="javascript:download();">出力</button>
            </p>
          </li>
        </ul>
      </div>
      <div id="display-wrapper">
        <canvas id="auxiliary-line">
        </canvas>
        <canvas id="display">
        </canvas>
      </div>
      <textarea id="monitor">
      </textarea>
    </div>
    <script>
      // ユーザー定義変数
      let displaySize = 700;
      let strokeStyle = [128, 128, 128, 1];
      let fillStyle = [255, 255, 255, 0.75];
      let focalLengthPercentage = 1;
      // 内部変数
      let displayRadius = displaySize / 2;
      let vectorSlideRadius = displaySize / 8 * 3;
      let rotateTheta = 0 / 180 * Math.PI;
      let vectorTheta = 0 / 180 * Math.PI;
      let lengthTheta = 0 / 180 * Math.PI;
      let viewingAngle = 0 / 180 * Math.PI;
      let moveSwitch = false;
      let latestMoveX = 0;
      let latestMoveY = 0;
      let latestBaseX = 0;
      let latestBaseY = 0;
      let moveType = "vector";
      let moveRotateTheta = 0;
      let moveVectorTheta = 0;
      let moveLengthTheta = 0;
      let diffRotateTheta = 0;
      let diffLengthTheta = 0;
      let rotateThetaBase = 0;
      let vectorThetaBase = 0;
      let lengthThetaBase = 0;
      let animationSwitch = false;
      let animationStartSwitch = false;
      let animation = null;
      let animationTimeout = null;
      let momentPoses = {};
      let momentSurfaces = [];
      let focalLengthSwitch = false;
      let meterHandleDiffX = 0;

      const displayWrapper = document.getElementById("display-wrapper");
      const display = document.getElementById("display");
      const displayContext = display.getContext("2d");
      const auxiliaryLine = document.getElementById("auxiliary-line");
      const auxiliaryLineContext = auxiliaryLine.getContext("2d");
      const monitor = document.getElementById("monitor");
      const inputR = document.getElementById("rotateTheta");
      const inputV = document.getElementById("vectorTheta");
      const inputL = document.getElementById("lengthTheta");
      const inputD = document.getElementById("displaySize");
      const inputF = document.getElementById("focalLength");
      const meter = document.getElementById("focal-length-meter");
      const meterHandle = document.getElementById("focal-length-meter-handle");

      const positions = Object.keys(coordinates).reduce((res, code) => {
        const relPos = coordinates[code];
        const l1 = Math.pow(relPos.X * relPos.X + relPos.Y * relPos.Y, 1 / 2);
        const l2 = Math.pow(relPos.Z * relPos.Z + l1 * l1, 1 / 2);
        const X = Math.acos(relPos.Z / l2);
        let Y = l1 > 0 ? Math.asin(relPos.X / l1) + Math.PI : 0;
        if (relPos.Y < 0) {
          Y = Math.PI - Y;
        }

        return { ...res, [code]: { R: l2, X, Y }};
      }, {});

      const getLengthByPytha = (hypotenuse, cathetus1, cathetus2) => {
        switch (null) {
          case hypotenuse: return Math.pow((Math.pow(cathetus1,  2) + Math.pow(cathetus2, 2)), (1 / 2));
          case cathetus1:  return Math.pow((Math.pow(hypotenuse, 2) - Math.pow(cathetus2, 2)), (1 / 2));
          case cathetus2:  return Math.pow((Math.pow(hypotenuse, 2) - Math.pow(cathetus1, 2)), (1 / 2));
        }
      };

      const getThetaByLengthes = (thetaCode, X, Y) => {
        const X_ABS = Math.abs(X);
        const Y_ABS = Math.abs(Y);
        const TA_ZR = 0;
        const TA_LG = Math.PI / 2;
        const TR_ZR = Math.PI * -1;
        const TR_LG = Math.PI * -1 / 2;

        switch (thetaCode) {
          case 'X':
            if (X > 0 && Y > 0) return TR_LG + Math.atan(Y_ABS / X_ABS);
            if (X > 0 && Y <= 0) return TR_LG - Math.atan(Y_ABS / X_ABS);
            if (X < 0 && Y > 0) return TA_LG - Math.atan(Y_ABS / X_ABS);
            if (X < 0 && Y <= 0) return TA_LG + Math.atan(Y_ABS / X_ABS);
            if (X === 0 && Y > 0) return TA_ZR;
            if (X === 0 && Y <= 0) return TR_ZR;
          case 'Y':
            if (X > 0 && Y > 0) return TR_LG - Math.atan(Y_ABS / X_ABS);
            if (X > 0 && Y <= 0) return TR_LG + Math.atan(Y_ABS / X_ABS);
            if (X < 0 && Y > 0) return TA_LG + Math.atan(Y_ABS / X_ABS);
            if (X < 0 && Y <= 0) return TA_LG - Math.atan(Y_ABS / X_ABS);
            if (X === 0 && Y > 0) return TR_ZR;
            if (X === 0 && Y <= 0) return TA_ZR;
          case 'Z':
            if (X > 0 && Y > 0) return TA_ZR - Math.atan(Y_ABS / X_ABS);
            if (X > 0 && Y <= 0) return TA_ZR + Math.atan(Y_ABS / X_ABS);
            if (X < 0 && Y > 0) return TR_ZR + Math.atan(Y_ABS / X_ABS);
            if (X < 0 && Y <= 0) return TR_ZR - Math.atan(Y_ABS / X_ABS);
            if (X === 0 && Y > 0) return TR_LG;
            if (X === 0 && Y <= 0) return TA_LG;
          default:
        }

        return 0;
      };

      const getLengthesByTheta = (thetaCode, theta) => {
        theta = theta % (Math.PI * 2);
        theta = theta > Math.PI ? theta - Math.PI * 2 : theta;
        theta = theta < Math.PI * -1 ? theta + Math.PI * 2 : theta;

        const T_ABS = Math.abs(theta);
        const S_ABS = Math.abs(Math.sin(theta));
        const C_ABS = Math.abs(Math.cos(theta));
        const TA_ZR = 0;
        const TA_LG = Math.PI / 2;
        const TR_ZR = Math.PI * -1;
        const TR_LG = Math.PI * -1 / 2;

        switch (thetaCode) {
          case 'X':
            return {
              X: theta > TA_ZR ? S_ABS * -1 : S_ABS,
              Y: T_ABS > TA_LG ? C_ABS * -1 : C_ABS,
            };
          case 'Y':
            return {
              X: theta > TA_ZR ? S_ABS * -1 : S_ABS,
              Y: T_ABS > TA_LG ? C_ABS : C_ABS * -1,
            };
          case 'Z':
            return {
              X: T_ABS > TA_LG ? C_ABS * -1 : C_ABS,
              Y: theta > TA_ZR ? S_ABS * -1 : S_ABS,
            };
        }
      };

      const getThetasByRelative = (base_rotateTheta, base_vectorTheta, base_lengthTheta, moveRotateTheta, moveVectorTheta, moveLengthTheta) => {
        const TA0 = moveVectorTheta - Math.PI / 2;
        const TY0 = base_vectorTheta - TA0;
        const LS0 = getLengthesByTheta('Z', base_lengthTheta);
        const RY0 = LS0.Y;
        const LZ0 = LS0.X;
        const LS1 = getLengthesByTheta('Y', TY0);
        const LX1 = LS1.X * RY0;
        const LY1 = LS1.Y * RY0;
        const RX1 = getLengthByPytha(null, LX1, LZ0);
        const TX1 = getThetaByLengthes('X', LX1, LZ0);
        const TX2 = TX1 + moveLengthTheta;
        const LS2 = getLengthesByTheta('X', TX2);
        const LX2 = LS2.X * RX1;
        const LZ2 = LS2.Y * RX1;
        const RY2 = getLengthByPytha(null, LX2, LY1);
        const TL2 = getThetaByLengthes('Z', LZ2, RY2);
        const TV2 = getThetaByLengthes('Y', LX2, LY1);

        if (LY1 === 0) {
          return {
            rotateTheta: base_rotateTheta,
            vectorTheta: TV2 + TA0,
            lengthTheta: TL2
          };
        }

        const LS3 = getLengthesByTheta('X', TX1);
        const LX3 = LS3.X * RX1;
        const LZ3 = LS3.Y * RX1;
        const RY3 = getLengthByPytha(null, LX3, LY1);
        const TL3 = getThetaByLengthes('Z', LZ3, RY3);
        const TV3 = getThetaByLengthes('Y', LX3, LY1);
        const L0 = Math.sin(TV3);
        const L1 = Math.cos(TV3);
        const L2 = Math.cos(TL3) * L1;
        const T0 = getThetaByLengthes('Y', L2, L0);
        const T1 = T0 + TV3;
        const L3 = Math.sin(TV2);
        const L4 = Math.cos(TV2);
        const L5 = Math.cos(TL2) * L4;
        const T2 = getThetaByLengthes('Y', L5, L3);
        const T3 = T2 + TV2;
        const TX = T3 - T1;

        return {
          rotateTheta: TX + base_rotateTheta,
          vectorTheta: TV2 + TA0,
          lengthTheta: TL2
        };
      };

      const output = () => {
        const axisTheta = vectorTheta - (Math.PI / 2);

        momentSurfaces = [];

        for (const surfaceCode in surfaces) {
          let zIndex = 0;

          surfaces[surfaceCode].forEach((posCode) => {
            let X = 0;
            let Y = 0;
            let Z = 0;

            if (posCode !== "O") {
              const LS0 = getLengthesByTheta("Z", positions[posCode].X);
              const RY0 = LS0.Y;
              const LZ0 = LS0.X;
              const TY1 = positions[posCode].Y + rotateTheta - axisTheta;
              const LS1 = getLengthesByTheta("Y", TY1);
              const LX1 = LS1.X * RY0;
              const LY1 = LS1.Y * RY0;
              const TX1 = getThetaByLengthes("X", LX1, LZ0);
              const RX1 = getLengthByPytha(null, LX1, LZ0);
              const TX2 = TX1 + lengthTheta;
              const LS2 = getLengthesByTheta("X", TX2);
              const LX2 = LS2.X * RX1;
              const LZ2 = LS2.Y * RX1;
              const TY2 = getThetaByLengthes("Y", LX2, LY1);
              const RY2 = getLengthByPytha(null, LX2, LY1);
              const TY3 = TY2 + axisTheta;
              const LS3 = getLengthesByTheta("Y", TY3);
              const LX3 = LS3.X * RY2;
              const LY3 = LS3.Y * RY2;

              X = LX3 * positions[posCode].R;
              Y = LY3 * positions[posCode].R;
              Z = LZ2 * positions[posCode].R;
              if (focalLengthPercentage) {
                const focalLength = displaySize * focalLengthPercentage;
                X *= displayRadius / Math.abs(displayRadius * (focalLength - LZ2 * positions[posCode].R) / focalLength);
                Y *= displayRadius / Math.abs(displayRadius * (focalLength - LZ2 * positions[posCode].R) / focalLength);
              }
            }

            momentPoses[posCode] = { X, Y, Z };

            zIndex += Z;
          });

          momentSurfaces.push({
            code: surfaceCode,
            z_index: (zIndex / surfaces[surfaceCode].length)
          });
        }

        momentSurfaces.sort((A, B) => A.z_index - B.z_index);

        displayContext.setTransform(1, 0, 0, 1, 0, 0);
        displayContext.clearRect(0, 0, displaySize, displaySize);

        momentSurfaces.forEach((momentSurface) => {
          displayContext.beginPath();

          surfaces[momentSurface.code].forEach((posCode, j) => {
            const pos = momentPoses[posCode];

            if (j === 0) {
              displayContext.moveTo(displayRadius + pos.X, displayRadius + pos.Y);
            } else {
              displayContext.lineTo(displayRadius + pos.X, displayRadius + pos.Y);
            }
          });

          displayContext.closePath();
          displayContext.fill();
          displayContext.stroke();
        });

        inputR.value = rotateTheta * 180 / Math.PI;
        inputV.value = vectorTheta * 180 / Math.PI;
        inputL.value = lengthTheta * 180 / Math.PI;
      };

      const outputAuxiliaryLine = () => {
        const RL = getLengthesByTheta('Z', rotateThetaBase);
        const RsinLength = displaySize * RL.X;
        const RcosLength = displaySize * RL.Y;
        auxiliaryLineContext.setTransform(1, 0, 0, 1, 0, 0);
        auxiliaryLineContext.clearRect(0, 0, displaySize, displaySize);
        auxiliaryLineContext.strokeStyle = '#aaaaaa';
        auxiliaryLineContext.beginPath();
        auxiliaryLineContext.moveTo(0, displayRadius + 0.5);
        auxiliaryLineContext.lineTo(displaySize, displayRadius + 0.5);
        auxiliaryLineContext.stroke();
        auxiliaryLineContext.beginPath();
        auxiliaryLineContext.moveTo(displayRadius + 0.5, 0);
        auxiliaryLineContext.lineTo(displayRadius + 0.5, displaySize);
        auxiliaryLineContext.stroke();
        auxiliaryLineContext.strokeStyle = '#eeeeee';
        auxiliaryLineContext.beginPath();
        auxiliaryLineContext.arc(displayRadius + 0.5, displayRadius + 0.5, vectorSlideRadius, 0, Math.PI * 2);
        auxiliaryLineContext.stroke();
        auxiliaryLineContext.strokeStyle = '#ffaaaa';
        auxiliaryLineContext.beginPath();
        auxiliaryLineContext.moveTo(displayRadius + 0.5 + RcosLength, displayRadius + 0.5 - RsinLength);
        auxiliaryLineContext.lineTo(displayRadius + 0.5 - RcosLength, displayRadius + 0.5 + RsinLength);
        auxiliaryLineContext.stroke();
        const VL = getLengthesByTheta('Z', vectorThetaBase);
        const VsinLength = displayRadius * VL.X;
        const VcosLength = displayRadius * VL.Y;
        auxiliaryLineContext.strokeStyle = '#bbeebb';
        auxiliaryLineContext.beginPath();
        auxiliaryLineContext.moveTo(displayRadius + 0.5 + VcosLength, displayRadius + 0.5 - VsinLength);
        auxiliaryLineContext.lineTo(displayRadius + 0.5 - VcosLength, displayRadius + 0.5 + VsinLength);
        auxiliaryLineContext.stroke();
      };

      const move = () => {
        rotateThetaBase = rotateTheta;
        vectorThetaBase = vectorTheta;
        lengthThetaBase = lengthTheta;

        if (moveType === "vector") {
          const diffX = latestMoveX - latestBaseX;
          const diffY = latestMoveY - latestBaseY;
          const direction_X = diffX > 0 ? -1 : 1;
          const direction_Y = diffY > 0 ? 1 : -1;

          let absX = Math.abs(diffX);
          let absY = Math.abs(diffY);
          if (absX > 30) absX = 30;
          if (absY > 30) absY = 30;

          const thetaDiffX = absX / 200 * direction_X;
          const thetaDiffY = absY / 200 * direction_Y;

          moveRotateTheta = 0;
          moveVectorTheta = getThetaByLengthes('Y', thetaDiffX, thetaDiffY) * -1 + Math.PI;
          moveLengthTheta = 0;
          diffLengthTheta = getLengthByPytha(null, thetaDiffX, thetaDiffY);
          diffRotateTheta = 0;
        } else {
          const LD0X = latestBaseX - displayRadius;
          const LD0Y = latestBaseY - displayRadius;
          const LD1X = latestMoveX - displayRadius;
          const LD1Y = latestMoveY - displayRadius;
          const TD0 = getThetaByLengthes('Y', LD0X, LD0Y);
          const TD1 = getThetaByLengthes('Y', LD1X, LD1Y);
          const TD2 = TD1 - TD0;

          const direction_T = TD2 > 0 ? 1 : -1;

          let absT = Math.abs(TD2);
          if (absT > 0.2) absT = 0.2;

          const thetaDiff = absT * direction_T;

          moveRotateTheta = 0;
          moveLengthTheta = 0;
          diffLengthTheta = 0;
          diffRotateTheta = thetaDiff;
        }

        outputAuxiliaryLine();

        latestBaseX = latestMoveX;
        latestBaseY = latestMoveY;
      };

      const slide = () => {
        if (diffLengthTheta > 0) {
          moveLengthTheta += diffLengthTheta;

          const thetas = getThetasByRelative(
            rotateThetaBase,
            vectorThetaBase,
            lengthThetaBase,
            moveRotateTheta,
            moveVectorTheta,
            moveLengthTheta,
          );

          rotateTheta = thetas.rotateTheta;
          vectorTheta = thetas.vectorTheta;
          lengthTheta = thetas.lengthTheta;
        } else if (diffRotateTheta != 0) {
          moveRotateTheta += diffRotateTheta;
          rotateTheta = rotateThetaBase + moveRotateTheta;
          vectorTheta = vectorThetaBase + moveRotateTheta;
        }
      };
      const animate = () => {
        if (moveSwitch === true) move();
        slide();
        output();
      };

      const startAnimation = () => {
        if (animation) clearInterval(animation);

        animationSwitch = true;
        animation = setInterval(animate, 50);
      };

      const stopAnimation = () => {
        if (animation) clearInterval(animation);

        animationSwitch = false;
        animationStartSwitch = false;
      };

      const moveStopCheck = (clientX, clientY) => {
        animationStartSwitch = latestMoveX !== clientX || latestMoveY !== clientY;
      };

      const resize = () => {
        displayWrapper.style.width = `${displaySize + 2}px`;
        displayWrapper.style.height = `${displaySize + 2}px`;
        display.setAttribute("width", displaySize);
        display.setAttribute("height", displaySize);
        auxiliaryLine.setAttribute("width", displaySize);
        auxiliaryLine.setAttribute("height", displaySize);
        inputD.value = displaySize;
        displayContext.strokeStyle = `rgba(${strokeStyle[0]}, ${strokeStyle[1]}, ${strokeStyle[2]}, ${strokeStyle[3]})`;
        displayContext.fillStyle = `rgba(${fillStyle[0]}, ${fillStyle[1]}, ${fillStyle[2]}, ${fillStyle[3]})`;
      };

      const setFocalLengthSwitch = (operate, clientX) => {
        focalLengthSwitch = operate;
        if (operate === false) return;

        const meterHandleRect = meterHandle.getBoundingClientRect();
        if (clientX >= meterHandleRect.left && clientX <= meterHandleRect.left + meterHandleRect.width) {
          meterHandleDiffX = clientX - (meterHandleRect.left + meterHandleRect.width / 2);
        } else {
          meterHandleDiffX = 0;
          setFocalLength(clientX);
        }
      };

      const setFocalLength = (clientX) => {
        const meterRect = meter.getBoundingClientRect();
        const meterHandleRect = meterHandle.getBoundingClientRect();
        const meterLeft = meterRect.left + meterHandleRect.width / 2;
        const meterRight = meterRect.left + meterRect.width - meterHandleRect.width / 2;
        const meterWidth = meterRight - meterLeft;
        let percentage = (clientX - meterHandleDiffX - meterLeft) / meterWidth;
        if (percentage < 0) percentage = 0;
        if (percentage > 1) percentage = 1;
        focalLengthPercentage = 1 / 2 + 2 * percentage;
        meterHandle.style.left = `${Math.floor(meterWidth * percentage)}px`;
        inputF.value = Math.floor(displaySize * focalLengthPercentage);

        if (!animationSwitch) output();
      };

      const debug = () => {
        rotateTheta = parseFloat(inputR.value || 0) / 180 * Math.PI;
        vectorTheta = parseFloat(inputV.value || 0) / 180 * Math.PI;
        lengthTheta = parseFloat(inputL.value || 0) / 180 * Math.PI;

        stopAnimation();
        output();
        monitor.value = Object.keys(momentPoses).reduce((res, posCode) => `${res}${posCode}: ${Math.round(momentPoses[posCode].X * 1000) / 1000} ${Math.round(momentPoses[posCode].Y * 1000) / 1000}\n`, '');
      };

      const download = () => {
        stopAnimation();

        const fillStyleText = `#${fillStyle[0].toString(16)}${fillStyle[1].toString(16)}${fillStyle[2].toString(16)}`;
        const strokeStyleText = `#${strokeStyle[0].toString(16)}${strokeStyle[1].toString(16)}${strokeStyle[2].toString(16)}`;
        const svg =
          '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n' +
          `<svg x="0px" y="0px" width="${displaySize}px" height="${displaySize}px">\n` +
          '<g inkscape:label="レイヤー 1" inkscape:groupmode="layer" id="layer1">\n' +
          momentSurfaces.reduce((res, surface) => (
            res +
            `<path style="fill:${fillStyleText};fill-opacity:${fillStyle[3]};stroke:${strokeStyleText};stroke-width:1px;stroke-opacity:${strokeStyle[3]}" d="M ` +
            surfaces[surface.code].reduce((path, posCode, j) => (
              path +
              `${displayRadius + Math.round(momentPoses[posCode].X * 1000) / 1000} ` +
              `${displayRadius + Math.round(momentPoses[posCode].Y * 1000) / 1000}` +
              (j + 1 === surfaces[surface.code].length ? surfaces[surface.code].length < 3 ? '' : ' Z' : ' L ')
            ), '') +
            `" />\n`
          ), '') +
          '<text xml:space="preserve" style="font-size:15px;line-height:1;font-family:\'UD Digi Kyokasho NP-R\';fill:#000000;fill-opacity:1;stroke:none" x="0" y="16">' +
          `<tspan sodipodi:role="line" x="0" y="16">F: ${Math.floor(displaySize * focalLengthPercentage)}</tspan>` +
          `<tspan sodipodi:role="line" x="0" y="32">R: ${rotateTheta * 180 / Math.PI}</tspan>` +
          `<tspan sodipodi:role="line" x="0" y="48">V: ${vectorTheta * 180 / Math.PI}</tspan>` +
          `<tspan sodipodi:role="line" x="0" y="64">L: ${lengthTheta * 180 / Math.PI}</tspan>` +
          '</text></g>\n</svg>';
        const blob = new Blob([svg], { type: 'text/plan' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'coordinates.svg';
        link.click();
      };

      const getClientPosition = (event) => ({
        X: event.clientX !== undefined ? event.clientX : event.changedTouches[0].clientX,
        Y: event.clientY !== undefined ? event.clientY : event.changedTouches[0].clientY,
      });

      const displayOnpointerdown = (event) => {
        if (moveSwitch === true || focalLengthSwitch === true) return;

        stopAnimation();

        const { X, Y } = getClientPosition(event);

        moveSwitch = true;
        latestMoveX = X;
        latestMoveY = Y;
        latestBaseX = X;
        latestBaseY = Y;

        const displayRect = display.getBoundingClientRect();
        const relativeDiffX = Math.abs(X - displayRect.left - displayRadius);
        const relativeDiffY = Math.abs(Y - displayRect.top - displayRadius);
        const relativeDiffRadius = getLengthByPytha(null, relativeDiffX, relativeDiffY);
        moveType = relativeDiffRadius <= vectorSlideRadius ? "vector" : "rotate";
      };

      const documentMousemove = (event) => {
        const { X, Y } = getClientPosition(event);

        if (moveSwitch === true) {
          animationStartSwitch = true;
          clearTimeout(animationTimeout);
          animationTimeout = setTimeout(() => {
            moveStopCheck(X, Y);
          }, 100);
          latestMoveX = X;
          latestMoveY = Y;
          animate();
        } else if (focalLengthSwitch === true) {
          setFocalLength(X);
        } 
      };

      document.onpointerup = (event) => {
        if (moveSwitch === true) {
          moveSwitch = false;

          const { X, Y } = getClientPosition(event);
          latestMoveX = X;
          latestMoveY = Y;
        }

        if (animationStartSwitch) startAnimation();
        setFocalLengthSwitch(false);
      };

      document.onkeydown = (event) => {
        if (event.code !== "Enter") return;

        if (animationSwitch === false) {
          startAnimation();
        } else {
          stopAnimation();
        }
      };

      meter.onpointerdown = (event) => {
        setFocalLengthSwitch(true, getClientPosition(event).X);
      };

      if (typeof display.ontouchstart === 'object') {
        display.ontouchstart = displayOnpointerdown;
      } else {
        display.onpointerdown = displayOnpointerdown;
      }
      if (typeof document.ontouchmove === 'object') {
        document.ontouchmove = documentMousemove;
      } else {
        document.onmousemove = documentMousemove;
      }

      inputR.onfocus = stopAnimation;
      inputV.onfocus = stopAnimation;
      inputL.onfocus = stopAnimation;
      inputF.value = Math.floor(displaySize * focalLengthPercentage);

      resize();
      outputAuxiliaryLine();
      output();
    </script>
  </body>
</html>
